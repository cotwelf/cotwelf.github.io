
<!DOCTYPE html>
<html lang="zh ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cotwelf&#39;s Life || 前端芝士补完计划 之 Web 性能和安全</title>
    <meta name="author" content="Cotwelf">
    <meta name="description" content="誰か聞こえますか。見えますか。 ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="//images/cover/77.jpeg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="layout">
      <transition name="into">
          <div v-show="show_page" style="display: none;">
            
              <div id="menu_show">
                 
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Cotwelf's Life</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>主页</span>
        </a>
        
        <a href="/categories/前端/">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>分类</span>
        </a>
        
        <a href="/tags">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>标签</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>时间轴</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>关于我</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>Cotwelf's Life</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">主页</div>
                </div>
            </a>
            
            <a href="/categories/前端/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">分类</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">标签</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">时间轴</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">关于我</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
              </div>
            
              <div id="main">
                  
<link rel="stylesheet" href="/css/post-body.css">

  <div class="article" id="article">
    
    <div>
      <h1>前端芝士补完计划 之 Web 性能和安全 </h1>
    </div>
    <div class="info">
        
        <span class="category">
            <a href="/categories/前端">
                <span class="icon">
                    <a-icon type="book" theme="filled" />
                </span>
                前端
            </a>
        </span>
        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/基础" style=color:#ffa2c4>
                    基础
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/性能" style=color:#ff7d73>
                    性能
                </a>
            </span>
            
        </span>
        
    </div>
    

      <div class="content" v-if="release"><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h3 id="1-请简单介绍一下图像的预加载和懒加载"><a href="#1-请简单介绍一下图像的预加载和懒加载" class="headerlink" title="1. 请简单介绍一下图像的预加载和懒加载"></a>1. 请简单介绍一下图像的预加载和懒加载</h3><h4 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h4><p><code>提前加载图像</code>，并将其缓存，当要访问时就能直接读取缓存中的图像。预加载不但能更流畅地展示网页，减少等待时间，还能<code>防止页面因图像太多而打开缓慢</code>甚至无法打开的情况发生。</p>
<pre><code class="javascript">import picture from &#39;xxx&#39; // 引入一张图片，或者从接口请求到图片的 url

let img = new Image()
img.setAttribute(&#39;crossOrigin&#39;, &#39;Anonymous&#39;) // 如果在 canvas 中用到图片，最好允许跨域，否则一些方法会报错（比如 canvas.toDataURL(&#39;image/png&#39;)
img.onload = () =&gt; &#123;
  // 图片加载完成后执行的一些逻辑
&#125;
// 需要先定义 onload, 再赋值 src, 不然会出现资源返回，但是 onload 还没有挂载的情况。一个 img 是有了 src 之后才开始请求资源的。
img.src = picture
// 然后再用 img 这张图片做其他的事情，绑定 jsx 的 src 鸭之类的
</code></pre>
<p>另外，我们的 css 一般都会放在头部，所以可以在 css 中用 background-image 给容器添加图片，来达到预加载的效果</p>
<h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h4><p>也叫延迟加载，通常做法是当滚动条到达某个位置时（比如页面底部），再请求图像。这种方式能大大节约用户流量，并减轻服务器压力，提升用户体验。</p>
<pre><code class="javascript">// 假设给 body 添加两个 img
let createImg = () =&gt; &#123;
  let img = document.createElement(&#39;img&#39;)
  img.setAttribute(&#39;style&#39;, &#39;width: 300px; margin: 200px&#39;)
  // img.setAttribute(&#39;crossOrigin&#39;, &#39;&#39;)
  img.setAttribute(&#39;crossOrigin&#39;, &#39;Anonymous&#39;)
  img.onload = () =&gt; &#123;
    console.log(&#39;image loaded~&#39;)
  &#125;
  return img
&#125;
let img1 = createImg()
let img2 = createImg()
document.body.append(img1, img2)
// 这时候可以滚动页面看一下，&#39;image loaded~&#39; 并没有被打印在控制台里。
window.addEventListener(&#39;scroll&#39;, () =&gt; &#123;
  // 在标准w3c下，document.body.scrollTop 恒为 0，需要用 document.documentElement.scrollTop 来代替;
  let A = document.documentElement.clientHeight // 视口高度
  let img1Top = img1.offsetTop
  let img2Top = img2.offsetTop
  let C = document.documentElement.scrollTop // 滚动条滚动的距离（也就是 html 向上卷入不可见领域的高度
  if (img1Top - C &lt; A &amp;&amp; !img1.src) &#123;
    img1.src = &#39;/images/cover/7.webp&#39;
  &#125;
  if (img2Top - C &lt; A &amp;&amp; !img2.src) &#123;
    img2.src = &#39;/images/cover/7777.webp&#39;
  &#125;
&#125;)
</code></pre>
<p><a href="#%E7%9B%AE%E5%BD%95">&gt;&gt; 返回目录</a></p>
<h3 id="2-CDN-是什么？"><a href="#2-CDN-是什么？" class="headerlink" title="2. CDN 是什么？"></a>2. CDN 是什么？</h3><p>CDN 部署策略</p>
<p>CDN（Content Delivery Network）即内容分发网络，是用来提升文件下载速度的一种机制。CDN 能实时地根据网络流量、负载状态、用户的距离和响应时间等综合信息，把用户的请求导向离它最近的节点服务器上，使用户能就近获取所需内容。</p>
<p>CDN服务只可以用于静态数据的加速。</p>
<p>下面以 baidu.com 简单说一下域名解析过程：</p>
<ul>
<li><ol>
<li>检查本机 hosts 文件，是否存在 baidu.com 对应的 IP。无，到 2；</li>
</ol>
</li>
<li><ol start="2">
<li>请求 Local DNS 是否有 <code>域名解析结果的缓存</code>。无，到 3，有，返回并标识是从 <code>非权威域名服务器</code> 返回的结果；</li>
</ol>
</li>
<li><ol start="3">
<li>开始 DNS 的迭代查询：</li>
</ol>
<ul>
<li>（1）Local DNS 先请求 <code>根 DNS</code>，根 DNS 返回 <code>顶级域名服务器</code>（.com）的地址；</li>
<li>（2）Local DNS 请求 .com 顶级域名服务器，得到 baidu.com 的 <code>权威域名服务器地址</code>；</li>
<li>（3）Local DNS 再从 baidu.com 的权威域名服务器中查询到 baidu.com <code>对应的 IP 地址</code> ，返回该地址，并标记结果来自于 <code>权威域名服务器</code> 的结果，同时 <code>写入 Local DNS 的解析结果缓存</code>，这样下次解析同一个域名就不用做 DNS 迭代查询了；</li>
</ul>
</li>
<li><ol start="4">
<li>客户端拿到域名 IP 后访问站点服务器，站点服务器应答请求，返回内容给客户端。</li>
</ol>
</li>
</ul>
<p>使用 CDN，相当于在上述步骤 3 和 4 中添加了一些操作</p>
<ul>
<li><ol start="3">
<li>开始 DNS 的迭代查询：</li>
</ol>
<ul>
<li>（1）Local DNS 先请求根 DNS，根 DNS 返回顶级域名服务器（.com）的地址；</li>
<li>（2）Local DNS 请求 .com 顶级域名服务器，得到 baidu.com 的权威域名服务器地址；</li>
<li>（3）Local DNS 再从 baidu.com 的权威域名服务器中查询 baidu.com 的 IP 地址，权威域名服务器查询后，返回 <code>CNAME</code> 给 Local DNS；</li>
<li>（4）Local DNS 得到 <code>域名记录（CNAME）后请求该地址，会重定向到 CDN（智能调度 DNS）服务，CDN通过一组预先定义好的策略(如内容类型、地理区域、网络负载状况等)，将当时能够最快响应用户的 CDN 节点 IP 地址</code>返回给 Local DNS；</li>
</ul>
</li>
<li><ol start="4">
<li>客户端拿到域名 IP 后访问站点服务器，<code>CDN 节点服务器</code> 应答请求，返回内容给客户端。</li>
</ol>
</li>
</ul>
<p>如果想要更深入了解 CDN 是如何实现加速的，可以看看 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/348012432">《CDN：静态资源如何加速？》</a></p>
<p><a href="#%E7%9B%AE%E5%BD%95">&gt;&gt; 返回目录</a></p>
<h3 id="3-平时会用到哪些方法来优化页面的性能"><a href="#3-平时会用到哪些方法来优化页面的性能" class="headerlink" title="3. 平时会用到哪些方法来优化页面的性能"></a>3. 平时会用到哪些方法来优化页面的性能</h3><h4 id="优化请求"><a href="#优化请求" class="headerlink" title="优化请求"></a>优化请求</h4><ul>
<li>合并文件</li>
<li>缓存资源</li>
<li>使用 CDN</li>
</ul>
<h4 id="优化-CSS"><a href="#优化-CSS" class="headerlink" title="优化 CSS"></a>优化 CSS</h4><ul>
<li>将 CSS 文件置于 HTML 头部，使用外部样式，压缩 CSS 文件等</li>
</ul>
<h4 id="优化-JS"><a href="#优化-JS" class="headerlink" title="优化 JS"></a>优化 JS</h4><ul>
<li>减小重绘与重排</li>
<li>避免内联脚本阻塞下载，把脚本置于 HTML 文档底部</li>
<li>惰性载入函数</li>
</ul>
<h4 id="优化图像"><a href="#优化图像" class="headerlink" title="优化图像"></a>优化图像</h4><ul>
<li>压缩</li>
<li>合并：雪碧图（比如 postcss-sprites 插件</li>
<li>预加载</li>
<li>懒加载</li>
<li>使用 WebP 格式等（阿里云有图片转 WebP 服务</li>
</ul>
<p><a href="#%E7%9B%AE%E5%BD%95">&gt;&gt; 返回目录</a></p>
<h3 id="4-页面性能的参数一般会关注哪些参数？"><a href="#4-页面性能的参数一般会关注哪些参数？" class="headerlink" title="4. 页面性能的参数一般会关注哪些参数？"></a>4. 页面性能的参数一般会关注哪些参数？</h3><ul>
<li><p>（1）请求时间相关参数</p>
<p>白屏时间、加载总时间、DNS 查询耗时、TTFB（读取页面第一个字节时间）等</p>
</li>
<li><p>（2）资源载入信息</p>
<p>载入耗时、TTFB 和 TCP 连接耗时等</p>
</li>
<li><p>（3）网络状态和速度</p>
</li>
<li><p>（4）代理信息，包括操作系统、设备和浏览器等</p>
</li>
<li><p>（5）Ajax 请求监控，包括请求地址、请求耗时和传输字节量等。</p>
</li>
<li><p>（6）异常监控，包括异常的提示信息、行数、列数和地址等。</p>
</li>
</ul>
<p><a href="#%E7%9B%AE%E5%BD%95">&gt;&gt; 返回目录</a></p>
<h3 id="5-请简单解释一下-CSRF-的攻击原理和防御手段。"><a href="#5-请简单解释一下-CSRF-的攻击原理和防御手段。" class="headerlink" title="5. 请简单解释一下 CSRF 的攻击原理和防御手段。"></a>5. 请简单解释一下 CSRF 的攻击原理和防御手段。</h3><p>CSRF（Cross Site Request Forgery）即跨站点请求伪造，攻击者伪装成正常用户，对服务器发起请求，让服务器执行某些操作。例如用户正常登录某个网站，然后在未退出的情况下访问攻击者事先准备好的页面，此时攻击者就有可能获取到保存在 Cookie 中的登录凭据或登录信息，然后攻击者就能伪装成该用户，与服务器进行通信。</p>
<p>CSRF的防御手段如下所列：</p>
<ul>
<li>（1）让用户与网站交互才能完成请求，例如在表单中添加验证码（这是对抗 CSRF 最简洁有效的方式）；</li>
<li>（2）检查请求是否来自合法源，例如发起请求的页面是否合法，用户想要发起“删除声音”这个操作，一定是在【我的主页】下的声音 tab，如果 Referer 的值不是这个页面，甚至不是网站域名，很有可能是 CSRF 攻击，但缺点是出于隐私或安全考虑，浏览器可能不发送 referer（比如从 https 跳转到 http），服务器有可能获取不到；</li>
<li>（3）在每个请求中添加一个 Token 参数（Anti CSRF Token），这是一个随机数，可以在进入页面时生成，然后保存在 Session 中，服务器在接收到 Token 参数时进行校验，只有校验成功后菜执行后续操作。</li>
</ul>
<p><a href="#%E7%9B%AE%E5%BD%95">&gt;&gt; 返回目录</a></p>
<h3 id="6-XSS-是什么？对这种攻击有哪些防范办法？"><a href="#6-XSS-是什么？对这种攻击有哪些防范办法？" class="headerlink" title="6. XSS 是什么？对这种攻击有哪些防范办法？"></a>6. XSS 是什么？对这种攻击有哪些防范办法？</h3><p>XSS（Cross Site Script）即跨站脚本攻击，它将恶意脚本注入到目标网页中，用户在访问该页面时，有可能造成信息泄露、用户行为被劫持、感染并传播蠕虫病毒等危害。</p>
<p>防范办法如下：</p>
<ul>
<li>（1）为 Cookie 添加 HttpOnly 标记，使客户端不能通过 JS 读取 Cookie 信息</li>
<li>（2）对提交到服务器中的信息做输入校验，例如白名单过滤、把字符编码成 HTML 实体等（HTMLescape）。</li>
<li>（3）对输入到页面中的信息做输出检查，检查方式和第二种类似。</li>
</ul>
<p><a href="#%E7%9B%AE%E5%BD%95">&gt;&gt; 返回目录</a></p>
<h3 id="7-什么叫点击劫持？对这种攻击有什么解决办法？"><a href="#7-什么叫点击劫持？对这种攻击有什么解决办法？" class="headerlink" title="7. 什么叫点击劫持？对这种攻击有什么解决办法？"></a>7. 什么叫点击劫持？对这种攻击有什么解决办法？</h3><p>点击劫持（clickJacking）是一种视觉上的欺骗，攻击者把一个透明的 iframe 覆盖在目标网页的某个位置，这个位置可以使一个按钮、一段文字或一张图像等，诱使用户点击。</p>
<p>如果要防范该攻击，可以通过限制 iframe 来实现。只要在 HTTP 响应报文中添加 X-Frame-Options 首部，就能让浏览器按照要求加载 iframe 中的页面，可以是不加载、只加载相同域名或加载指定来源。</p>
<p>给 nginx 添加 header</p>
<pre><code class="nginx">add_header X-Frame-Options SAMEORIGIN;
</code></pre>
<p><a href="#%E7%9B%AE%E5%BD%95">&gt;&gt; 返回目录</a></p>
<h3 id="8-列举跨域方法"><a href="#8-列举跨域方法" class="headerlink" title="8. 列举跨域方法"></a>8. 列举跨域方法</h3><blockquote>
<p>跨域问题的由来，是为了防止请求被劫持或篡改（CSRF、XSS 和点击劫持都是跨域进行的基本上）</p>
</blockquote>
<p>跨域：浏览器在请求协议、域名、端口不同的服务器上的资源时，受浏览器同源策略影响，导致请求资源不成功。</p>
<h4 id="（2）跨域资源共享（CORS）"><a href="#（2）跨域资源共享（CORS）" class="headerlink" title="（2）跨域资源共享（CORS）"></a>（2）跨域资源共享（CORS）</h4><p>W3C 提出的一个标准，允许浏览器向跨域服务器发出 XMLHttpRequest 请求，是一种基于 HTTP 头的机制。</p>
<p>什么情况下需要 CORS</p>
<ul>
<li>XMLHttpRequest 或 Fetch APIs 发起的跨源 HTTP 请求；</li>
<li>Web 字体（CSS 中通过 <code>@font-face</code> 使用跨源字体）</li>
<li>WebGL 贴图</li>
<li>使用 <code>drawImage</code> 将 Images&#x2F;video 画面绘制到 canvas；</li>
<li>来自图像的 CSS 图形</li>
</ul>
<p>首先 CORS 需要浏览器和服务器同时支持（IE9- 不支持）。浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨源请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证 相关数据）</p>
<p>如果遇到跨域情况，可以修改 HTTP 响应头（Response headers）（Chrome 的话可以使用 ModHeader，也可以用 Charles 添加响应头模拟。</p>
<blockquote>
<p>默认情况下，跨源请求不提供凭据（cookie、HTTP 认证及客户端 SSL 证明等 ）。通过将 withCredentials 属性设置为 true，可以指定某个请求应该发送凭据。如果服务器接受带凭据的请求，会用 Access-Control-Allow-Credentials 头部来响应。如果发送的是带凭据的请求，但服务器的响应中没有包含这个头部，那么浏览器就不会把响应交给 JavaScript</p>
</blockquote>
<pre><code class="nginx">Access-Control-Allow-Credentials: true
Access-Control-Allow-Origin: &#123;发起请求所在页面的协议和域名，如 https://www.bilibili.com&#125;
</code></pre>
<blockquote>
<p>通过设置 Access-Control-Allow-Origin，我们可以在 B站 域名下访问百度的图片了 <code>fetch(&quot;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&quot;)</code>，否则会报</p>
</blockquote>
<pre><code>Access to fetch at &#39;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&#39; from origin &#39;https://www.bilibili.com&#39; has been blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. If an opaque response serves your needs, set the request&#39;s mode to &#39;no-cors&#39; to fetch the resource with CORS disabled.
</code></pre>
<h4 id="jsonp：JSON-with-Padding"><a href="#jsonp：JSON-with-Padding" class="headerlink" title="jsonp：JSON with Padding"></a>jsonp：JSON with Padding</h4><p><code>&lt;script&gt;</code> 标签没有同源限制，不可靠，且无法确定请求是否失败</p>
<h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><p><a href="#%E7%9B%AE%E5%BD%95">&gt;&gt; 返回目录</a></p>
<h3 id="9-惰性载入函数"><a href="#9-惰性载入函数" class="headerlink" title="9. 惰性载入函数"></a>9. 惰性载入函数</h3><p>惰性载入表示函数执行的分支仅会发生一次，避免没必要的重复执行代码。</p>
<p>适用场景：只有页面首次载入需要判断，之后的任何操作都不会对判断结果产生影响。（比如我们判断当前客户端是否是手机浏览器，那么只要在页面载入的时候判断一次就好，没必要之后每项操作都判断一下）</p>
<p>有两种实现惰性载入的方式：</p>
<h4 id="方法一：函数被调用时重新处理函数。"><a href="#方法一：函数被调用时重新处理函数。" class="headerlink" title="方法一：函数被调用时重新处理函数。"></a>方法一：函数被调用时重新处理函数。</h4><p>即第一次调用的过程中，该函数会被覆盖为另一个按合适方式执行的函数，这样任何对原函数的调用都不会经过其他分支了。</p>
<p>比如为 dom 添加方法，js 加载之后，浏览器版本其实是不会变的，所以没必要每次执行 addHandler 添加监听事件的时候都判断一下浏览器是否支持，所以可以这样修改：</p>
<pre><code class="diff">function addHandler(element, type, handler) &#123;
  if (element.addEventListener) &#123; // 所有主流浏览器，除了 IE 8 及更早 IE版本
-   element.addEventListener(type, handler, false)
+   addHandler = function(element, type, handler) &#123;
+     element.addEventListener(type, handler, false)
+   &#125;
  &#125; else if (element.attachEvent) &#123; // IE 8 及更早 IE 版本
-   element.attachEvent(&#39;on&#39; + type, handler)
+   addHandler = function(element, type, handler) &#123;
+     element.attachEvent(&#39;on&#39; + type, handler)
+   &#125;
  &#125; else &#123;
-   element[&#39;on&#39; + type] = handler
+   addHandler = function(element, type, handler) &#123;
+     element[&#39;on&#39; + type] = handler
+   &#125;
  &#125;
+  return addHandle()
&#125;
</code></pre>
<blockquote>
<p>注意：在上述这个栗子中其实没必要 return addHandle()，因为三个分支均无返回值，但如果需要返回值的话，就需要在这里加一下，只用于首次 return，因为之后 addHandler 就已经被覆盖了</p>
</blockquote>
<h4 id="方法二：声明函数时就指定适当的函数。"><a href="#方法二：声明函数时就指定适当的函数。" class="headerlink" title="方法二：声明函数时就指定适当的函数。"></a>方法二：声明函数时就指定适当的函数。</h4><p>使用立即执行函数，在第一次载入时就执行，返回适当的函数的指针给一个变量，之后访问变量就都会指向这个适当的函数了。这样只有代码首次加载时会损失一点性能</p>
<pre><code class="diff">- function addHandler(element, type, handler) &#123;
+ var addHandler = (function() &#123;
  if (element.addEventListener) &#123; // 所有主流浏览器，除了 IE 8 及更早 IE版本
-   element.addEventListener(type, handler, false)
+   return function(element, type, handler) &#123;
+     element.addEventListener(type, handler, false)
+   &#125;
  &#125; else if (element.attachEvent) &#123; // IE 8 及更早 IE 版本
-   element.attachEvent(&#39;on&#39; + type, handler)
+   return function(element, type, handler) &#123;
+     element.attachEvent(&#39;on&#39; + type, handler)
+   &#125;
  &#125; else &#123;
-   element[&#39;on&#39; + type] = handler
+   return function(element, type, handler) &#123;
+     element[&#39;on&#39; + type] = handler
+   &#125;
  &#125;
- &#125;
+ &#125;)()
</code></pre>
<p><a href="#%E7%9B%AE%E5%BD%95">&gt;&gt; 返回目录</a></p>
</div>
      <div class="content" v-if="!release">
        <div class="release-tip">肥肠抱歉！！这是一个只有主银才能看的文档哦 _(:з」∠)_</div>
        <input id="release-value" placeholder="请输入通关密令" v-model="releaseVal" ref='releaseVal' v-on:focus="onReleaseValChange()"/>
        <div class="release-err" v-if="releaseErr">{{ releaseErr }}</div>
        <button id="release-btn" v-on:click="onRelease()">封印解除</button>
        <div class="tips">友情提示：通关密令有效期只有 10 天。</div>
      </div>

      
  </div>


                  

  <footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2022 - 2024 Cotwelf&#39;s Life
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Cotwelf
        </div>
        <div></div>
        <!-- <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>
    <br />
  </footer>


<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>

              </div>
          </div>
      </transition>
    </div>
    <script>
  var setRelease = function(status){
    var release = {
      status,
      time: Math.floor(Date.now() / 1000)
    }
    try {
      localStorage.setItem('release', JSON.stringify(release))
    } catch {
      // PASS
    }
  }
  var getRelease = function() {
    var result = null
    try {
      result = JSON.parse(localStorage.getItem('release'))
    } catch {
      // PASS
    }
    return result
  }
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100,
            release: false,
            releaseVal: '',
            releaseErr: '',
            planList: [],
        },
        created: function () {
            var that = this
            var isPrivate = !!'' || '' === 'true'
            var releaseObj = getRelease()
            if (releaseObj && (Math.floor(Date.now() / 1000) - releaseObj.time > 24 * 36000)) {
              localStorage.clear('release')
            } else {
              that.release = true
            }
            that.setPlanList('')
            that.release = releaseObj && releaseObj.status || !isPrivate
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                    var scroll = document.documentElement.scrollTop
                    document.documentElement.scrollTop = scroll - 300
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {

            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
          setPlanList: function (data) {
            if(!data || typeof data !== 'string') {
              return
            }
            var that = this
            var currentData = JSON.parse(data).map(i => {
              var duringDay = Math.ceil((new Date(i.end_at).getTime() - Date.now()) / 3600000 / 24)
              i.duringDay = duringDay - 1
              var currentItems = i.items.map(j => {
                j.percent = Math.floor(j.done / j.total * 10000) / 100 + '%'
                j.isDelay = j.start_at ? (j.total - j.done) / (duringDay / 7 * j.weekly) > j.per : false
                j.currentPer = j.start_at ? Math.ceil((j.total - j.done) / (duringDay / 7 * j.weekly)) : 0
                return j
              })
              return i
            })
            that.planList = currentData
          },
          home_click: function () {
            window.scrollTo({
              top: window.innerHeight - 80,
              behavior: "smooth",
            });
          },
          onRelease: function(e) {
            var that = this
            if (this.releaseVal === '修文世界第一可爱') {
              that.release = true
              setRelease(true)
              that.releaseErr = ''
            } else {
              that.releaseErr = '嘟嘟噜~~ 通关密令不正确哟~'
            }
          },
          onReleaseValChange: function() {
            var that = this
            that.releaseErr = ''
          }
        }
    })
</script>


</body>

</html>
